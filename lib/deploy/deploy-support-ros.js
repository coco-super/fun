'use strict';

const fs = require('fs-extra');
const path = require('path');
const time = require('../time');
const uuid = require('uuid');
const client = require('../client');
const { getProfile } = require('../profile');
const _ = require('lodash');
const { green, red } = require('colors');
const debug = require('debug');
const promiseRetry = require('../retry');
const { promptForConfirmContinue } = require('../init/prompt');
const { displayTriggerInfo } = require('../../lib/trigger');

const Table = require('cli-table3');

const log = require('single-line-log').stdout;

const DEFAULT_ROS_TIMEOUT_IN_MINS = 10;
const requestOption = {
  method: 'POST'
};

const ROS_STATUS_COMPLETE = ['CREATE_COMPLETE', 'UPDATE_COMPLETE'];

const ROS_STATUS_PROGRESS = ['CREATE_IN_PROGRESS', 'UPDATE_IN_PROGRESS', 'DELETE_IN_PROGRESS', 'CHECK_IN_PROGRESS'];

const ROS_STATUS_FAILED = ['UPDATE_FAILED', 'CREATE_FAILED', 'DELETE_FAILED', 'ROLLBACK_FAILED', 'CHECK_FAILED'];

const ROS_RESOURCE_TYPE = 'ALIYUN::ROS::Stack';

const tableHeads = ['LogicalResourceId', 'ResourceType', 'Action', 'Property'];

const eventTableHeads = ['LogicalResourceId', 'Status'];

const ROS_TEMPLATE_PATH = path.join('.fun', 'tmp', 'rosTemplate.json');

async function findRosStack(rosClient, region, stackName) {
  const pageSize = 50;
  let requestPageNumber = 0;
  let totalCount;
  let pageNumber;

  let stack;

  do {
    const params = {
      'RegionId': region,
      'StackName.1': stackName,
      'PageSize': pageSize,
      'PageNumber': ++requestPageNumber,
      'ShowNestedStack': false
    };

    const rs = await rosClient.request('ListStacks', params, requestOption);

    totalCount = rs.TotalCount;
    pageNumber = rs.PageNumber;

    const stacks = rs.Stacks;

    stack = _.find(stacks, { StackName: stackName });
  } while (!stack && totalCount && pageNumber && pageNumber * pageSize < totalCount);

  return (stack || {}).StackId;
}

function generateChangeSetName() {
  return 'fun-' + uuid.v4();
}

async function updateChangeSet(rosClient, region, stackName, stackId, tpl) {
  try {
    const params = {
      'RegionId': region,
      'ChangeSetName': generateChangeSetName(),
      'StackId': stackId,
      'ChangeSetType': 'UPDATE',
      'Description': 'generated by Funcraft',
      'TemplateBody': JSON.stringify(tpl),
      'DisableRollback': false,
      'TimeoutInMinutes': DEFAULT_ROS_TIMEOUT_IN_MINS
    };
    debug('update stacks, params %s', params);

    const res = await rosClient.request('CreateChangeSet', params, requestOption);
    return res.ChangeSetId;
  } catch (e) {
    if (e.name === 'NotSupportedError' && e.data && e.data.Message && e.data.Message.indexOf('Update the completely same stack') !== -1) {
      throw new Error(red(`no need to update, your stack ${stackName} is already latest`)); // todo: 
    } else {
      throw e;
    }
  }
}

async function createChangeSet(rosClient, region, stackName, tpl) {
  const params = {
    'RegionId': region,
    'ChangeSetName': generateChangeSetName(),
    'StackName': stackName,
    'ChangeSetType': 'CREATE',
    'Description': 'generated by Funcraft',
    'TemplateBody': JSON.stringify(tpl),
    'DisableRollback': false,
    'TimeoutInMinutes': DEFAULT_ROS_TIMEOUT_IN_MINS
  };

  debug('create stacks, params %s', params);

  const res = await rosClient.request('CreateChangeSet', params, requestOption);
  return {
    'changeSetId': res.ChangeSetId,
    'stackId': res.StackId
  };
}

async function execChangeSet(rosClient, region, changeSetId) {
  const params = {
    'RegionId': region,
    'ChangeSetId': changeSetId
  };

  await rosClient.request('ExecuteChangeSet', params, requestOption);
}

async function getChangeSet(rosClient, changeSetId, region) {

  const params = {
    'RegionId': region,
    'ChangeSetId': changeSetId,
    'ShowTemplate': true
  };

  const res = await rosClient.request('GetChangeSet', params, requestOption);

  return res.Changes;
}

// ┌────────────────┬──────────────────────┬────────┬─────────────┐
// │ Id             │ ResourceType         │ Action │ Propertity  │
// ├────────────────┼──────────────────────┼────────┼─────────────┤
// │ RosDemo        │ ALIYUN::FC::Service  │ Modify │ Description │
// ├────────────────┼──────────────────────┼────────┼─────────────┤
// │                │                      │        │ Code        │
// │                │                      │        ├─────────────┤
// │ RosDemoRosDemo │ ALIYUN::FC::Function │ Modify │ Timeout     │
// │                │                      │        ├─────────────┤
// │                │                      │        │ Runtime     │
// └────────────────┴──────────────────────┴────────┴─────────────┘

async function localDiffDisplay(changes) {
  if (_.isEmpty(changes)) { return; }

  const table = new Table({
    head: tableHeads,
    style: {
      head: ['green'],
      border: [] //disable colors for the border
    }});

  const map = new Map();

  _.forEach(changes, change => {
    // key: [LogicalResourceId, ResourceType, Action] 
    // value: [Name1, Name2.....]
    const logicalResourceId = change.ResourceChange.LogicalResourceId;
    const resourceType = change.ResourceChange.ResourceType;
    const action = change.ResourceChange.Action;

    const key = [logicalResourceId, resourceType, action];
    const value = change.ResourceChange.Details.map(detail => detail.Target.Name);
    map.set(key, value);
  });

  for (let [key, value] of map.entries()) {

    const valueSize = value.length;

    const line = [
      {rowSpan: valueSize, content: key[0], vAlign: 'center'},
      {rowSpan: valueSize, content: key[1], vAlign: 'center'},
      {rowSpan: valueSize, content: key[2], vAlign: 'center'}
    ];

    if (_.isEmpty(value)) {

      line.push('/');
      table.push(line);
    } else {
      let first = true;

      for (const pro of value) {
        if (first) {
          line.push(pro);
          table.push(line);
          first = false;
        } else {
          table.push([pro]);
        }
      }
    }
  }
  console.log(`\nchangeset difference table:\n`);
  console.log(table.toString());
  console.log();
}

async function getStackEvents(rosClient, stackId, region, stackName) {

  let isComplete = false;

  const pageSize = 50;
  let requestPageNumber = 1;
  let totalCount;
  let pageNumber;

  let leftPageCollect = [];

  do {

    const params = {
      'StackId': stackId,
      'RegionId': region,
      'PageSize': pageSize,
      'PageNumber': requestPageNumber
    };

    await time.sleep(2000);

    const rs = await rosClient.request('ListStackEvents', params, requestOption);

    const events = rs.Events;

    totalCount = rs.TotalCount;
    pageNumber = rs.PageNumber;

    const index = _.findIndex(events, event => {

      return event.ResourceType === ROS_RESOURCE_TYPE && _.includes(ROS_STATUS_PROGRESS, event.Status);
    });

    // 0: find it but not begin
    if (index === 0 && requestPageNumber === 1) {
      return {
        isComplete: false,
        events: []
      };
    }

    // -1: not find
    if (index === -1) {

      leftPageCollect = _.concat(leftPageCollect, events);
      requestPageNumber++;
      continue;
    }

    const concatEvents = _.concat(leftPageCollect, events);

    let sliceEvents;

    if (requestPageNumber > 1) {

      sliceEvents = _.slice(concatEvents, 0, (requestPageNumber - 1) * pageSize + events.length - 1);

    } else {

      sliceEvents = _.slice(concatEvents, 0, index);
    }

    sliceEvents.forEach(e => {
      if (_.includes(ROS_STATUS_FAILED, e.Status)) {

        console.error(red(e.StatusReason));

        const url = `https://ros.console.aliyun.com/#/stack/${region}`;
        throw new Error(`\nDeploy failed, you can login to ${url} to see deploy logs.\n`);
      }
    });

    const complete = sliceEvents.filter(s => {
      return _.includes(ROS_STATUS_COMPLETE, s.Status);
    });

    const firstEvent = _.first(sliceEvents);

    isComplete = firstEvent.ResourceType === ROS_RESOURCE_TYPE && _.includes(ROS_STATUS_COMPLETE, firstEvent.Status);

    if (isComplete) {

      _.remove(complete, e => {

        return e.LogicalResourceId === stackName;
      });

      return {
        completed: isComplete,
        events: complete
      };
    }

    const logicalResourceIds = complete.map(c => c.LogicalResourceId);

    _.remove(sliceEvents, e => {

      return _.includes(logicalResourceIds, e.LogicalResourceId) && !_.includes(ROS_STATUS_COMPLETE, e.Status);
    });

    return {
      completed: isComplete,
      events: sliceEvents
    };

  } while (!isComplete && totalCount && pageNumber && pageNumber * pageSize < totalCount);
}

async function getTemplate(rosClient, stackId, region) {

  const params = {
    'RegionId': region,
    'StackId': stackId
  };

  debug('get template, params %s', params);

  const res = await rosClient.request('GetTemplate', params, requestOption);

  return res.TemplateBody;
}

// ┌─────────────────────────┬────────────────────┐
// │ LogicalResourceId       │ Status             │
// ├─────────────────────────┼────────────────────┤
// │ cdn-test-servicecdn-te… │ CREATE_COMPLETE    │
// ├─────────────────────────┼────────────────────┤
// │ cdn-test-servicecdn-te… │ CREATE_COMPLETE    │
// ├─────────────────────────┼────────────────────┤
// │ cdn-test-servicecdn-te… │ CREATE_COMPLETE    │
// ├─────────────────────────┼────────────────────┤
// │ cdn-test-service        │ CREATE_COMPLETE    │
// └─────────────────────────┴────────────────────┘

async function displayEventsStatus(events, stackName) {

  const table = new Table({
    head: eventTableHeads,
    style: {
      head: ['green'],
      border: []
    },
    colWidths: [30, 20] //set the widths of each column (optional)
  });

  events.filter(f => f.LogicalResourceId !== stackName)
    .forEach(e => {
      table.push([e.LogicalResourceId, e.Status]);
    });

  log(table.toString() + '\n');
}

async function deployByRos(baseDir, stackName, tpl, assumeYes) {
  const profile = await getProfile();
  const region = profile.defaultRegion;

  const rosClient = await client.getRosClient();

  let stackId = await findRosStack(rosClient, region, stackName);

  let changeSetId;

  if (!stackId) { // create

    const changeSet = await createChangeSet(rosClient, region, stackName, tpl);

    changeSetId = changeSet.changeSetId;
    stackId = changeSet.stackId;

  } else { // update
    changeSetId = await updateChangeSet(rosClient, region, stackName, stackId, tpl);
  }

  const changes = await getChangeSet(rosClient, changeSetId, region);

  await localDiffDisplay(changes);

  if (!assumeYes) {

    if (!await promptForConfirmContinue('Please confirm to continue.')) { return; }
  }

  await promiseRetry(async (retry, times) => {
    try {
      await execChangeSet(rosClient, region, changeSetId);
    } catch (e) {
      if (e.code === 'NotSupported' && e.data && e.data.Message
        && e.data.Message.indexOf('StatusEnum.CREATE_IN_PROGRESS is not supported')) {
        await time.sleep(1000);
        console.log('changeSet is in \'StatusEnum.CREATE_IN_PROGRESS\' status, try to exectue again');
        retry(e);
      } else {
        throw e;
      }
    }
  });

  console.log('waiting for the event to complete:\n');

  let isComplete = false;

  do {

    const { completed, events} = await getStackEvents(rosClient, stackId, region, stackName);

    await displayEventsStatus(events, stackName);

    isComplete = completed;

  } while (!isComplete);

  const rosTemplateData = await getTemplate(rosClient, stackId, region);

  const rosTemplateObj = await saveTemplate(baseDir, rosTemplateData);

  await detectHttpTrigger(rosTemplateObj);

  showRosDeployNextTips(region);
}

async function detectHttpTrigger(rosTemplateData) {
  for (const v of Object.values(rosTemplateData.Resources)) {
    if ((v || {}).Type === 'ALIYUN::FC::Trigger') {
      const triggerProp = v.Properties || {};
      if (triggerProp.TriggerType === 'http') {
        console.log();
        await displayTriggerInfo(triggerProp.ServiceName, triggerProp.FunctionName, triggerProp.TriggerName, triggerProp.TriggerConfig);
      }
    }
  }
}

async function saveTemplate(baseDir, rosTemplateData) {
  const rosTemplatePath = path.resolve(baseDir, ROS_TEMPLATE_PATH);

  let rosTemplateObj;
  try {
    rosTemplateObj = JSON.parse(rosTemplateData);
  } catch (err) {
    console.error(red(`Unable to parse JSON file ${rosTemplateData}. Error: ${err}`));
  }
  // format output
  await fs.outputFile(rosTemplatePath, JSON.stringify(rosTemplateObj, null, 4));

  return rosTemplateObj;
}

function showRosDeployNextTips(region) {

  const url = `https://ros.console.aliyun.com/#/stack/${region}`;

  console.log(green(`\nDeploy success, you can login to ${url} to see deploy logs.\n`));
}

module.exports = {
  deployByRos
};